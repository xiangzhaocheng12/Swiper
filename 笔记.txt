Django 中的类字典对象
request.GET
request.POST
request.FILES
request.session



Flase 中的类字典对象
request.args
request.form
request.files
session
---------------------
1. cookie  和session
  # 默认的 HTTP协议的端口是80，默认的HTTPS协议的端口号是443
2. 请求在Django 中执行的过程
    一. 从用户点击链接到页面显示的全过程？
        ① 点击   http://www.baidu.com
        ② 客户端进行 DNS 解析   www.abcd.com  -> 11.22.33.44
            # HTTP 协议是建立在 TCP 协议上的 "短链接"  协议： 只通信一次, 然后就断掉了
            # TCP 是全双工协议
        ③ 客户端和服务器简历 TCP 连接
            三次握手:
            1. client -> SYN -> server
            2. client <- ACK + SYN <- server
            3. client ->       ACK -> server
        ④ 浏览器构造'请求报文'
        ⑤ 浏览器将'请求报文'发送到服务器
    二. Django 中的操作
        ① Django 的  HTTP Server 接收客户端的请求报文
            # Http Server 用来：
            #    1. 接收和发送数据
            #    2. 建立和断开连接
        ② WSGI 模块将 "请求报文" 解析并封装成 HttpRequest 对象
        ------------------------------------->  process_request
        ③ 进行 URL 匹配, 得到对应的视图函数
        ------------------------------------->  process_view
        ④ 视图函数进行处理
            |-1. 获取、检查参数
            |-2. 进行业务逻辑处理(缓存、数据库、运算)
            |-3. 将结果数据转化成前端需要的格式(模板渲染, 封装 JSON)
            |---------------------------------->  process_template(这一层的中间件用的极少)
            |-4. 将结果封装成 HttpResponse 对象
            +--------------------------------------> 仅当出现异常时触发 process_exception


            --------------------------------->  process_response
        ⑤ WSGI 将 HttpResponse对象转化成"响应报文"
        ⑥ Http Server 将"响应报文" 传给客户端
        ⑥ HTTP Server 断开与客户端的连接
            1. server -> FIN ->client
            # 为什么不能把四次挥手的过程有化成三次挥手的过程？
            2. server <- ACK <- client

            中间的时间:等待传输结束, 客户端检查是否有丢包

            3. server <- FIN <- client
            4. server -> ACK -> client
        ⑦ 客户端接收"响应报文"
        ⑧ 客户端解析、渲染、呈现页面


索引
    哈希索引
        底层使用的是哈希表, 通过哈希表上面一个槽的位置来进行匹配
        时间复杂度: O(1)

    select * from user where name like '张%';   # 此时可以使用索引
    select * from user where name like '%张';   # 此时无法使用索引




    B 树, B+树

定位
    GPS
    基站定位
    WI-FI
    IP 定位
经度 -180~ 180
维度 -90 ~ 90

GEO Hash : 精度不高, 模糊匹配的方式


--------------------------------------------
Day06:
git
    branch
    master
    develop
    feature

    pull request -> 代码审核(新人如果三次代码审核都不行, 基本上就凉了)
user
    发短信(跟第三方平台的对接, 关键是看平台的接口文档, Celery异步[还可以做定时])
    登陆(中间件、session、Django 源码)
    查看交友资料信息(user表和profile表一对一的关系、外键、property)
    修改个人信息(Form、ModelForm)
    七牛云
        1. 客户端 -> 服务器, 获取 token
        2. 客户端 -> 七牛云: 携带 Token 上传头像
        3. 七牛云 -> 访问服务器:七牛云的回调(回调服务器, 服务器保存结构)
        4. 七牛云 -> 客户端:通知客户端上传成功
social
    推荐:
        1. 创建机器人: 独立脚本如何调用 Django 项目中的模块
        2. Django ORM
        3. 企业中的一些推荐
    '喜欢'接口:联合唯一, 联合主键(底层使用的都是联合唯一的索引来操作的)
        class Meta:
            unique_together = ('uid', 'sid')

        联合唯一
        create table swiped(
            uid int,
            sid int,
            unique(uid,sid)
        )
        联合主键
        create table swipped(
            uid it,
            sid int,
            primary key (uid, sid),
        )


python 垃圾会回收机制
- 引用计数
- 标记清除
- 分代收集

- - 引用计数:
a = 1234567
b = a
    python 会针对每个变量进行记录, 当前的引用计数会减一
del b   # 此时该变量会减少 1

- - 引用计数所不能回收的:
a = [1,2,3]
b = [3,2,1]
a.append(a)
b.append(a)    # 循环引用无法进行清除, 需要使用标记清除的方式

- - 分代收集:

装饰器:
def foo(func1):
    def wrapper(*args,**kwargs):

        return
    return

服务器的内存查看：
    top/htop/free

Linux 的五个命令:
    ps      grep    scp     chmod   chown

1. 查看CUP负载
top 命令:
    top - 14:15:11 up 142 days, 20:33,  6 users,  load average: 6.19, 4.39, 3.60
    load average(平均负载):   一分钟负载,     ,十分钟负载

    %Cpu0  : 83.7 us, 15.9 sy,  0.0 ni,  0.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
             user       system            idle(空闲的)
             我的服务器貌似要炸了?!

     PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND
    28077 root      10 -10  158800  47384   9840 S  9.3  2.5  14:52.31 AliYunDun
    26454 JiangCh+  20   0  214128  16996   4492 R  6.3  0.9   0:00.19 python3
    26457 JiangCh+  20   0  213556  16496   4484 R  6.3  0.9   0:00.19 python3
    12827 JiangCh+  20   0  492024  39332   5712 S  1.0  2.1   0:49.70 python

    TIME 表示实际占用CPU的时间

uptime:

2. 数据库的主从复制
    主机   <- 写入
      |
     bin_log
       从机: 产生一个线程, 把主机的日志搬运过来  relay_log
             然后把传过来的日志搬运到数据库中
             因此会产生两个线程, 一个IO进程, 一个sql线程
       从机  -> 读取
       从机  -> 读取
     读写分离

-------------------------------------------------------------------------------------
Day07
简历:
Web 项目:
    微博:
        发表
        评论、回复(id、uid、wid、cid) content
        点赞、关注

Swiper
    缓存的处理、
    状态码的处理、
    异常的处理、
    关注和被关注



App 种类: 可以将电商的功能集成到其中
- 厨艺类: 下厨房
- 教育类: 小猿搜题、作业帮
- 财经类: 雪球、同花顺
- 阅读类: 微信读书、起点、掌阅(服务器用python写的)
- 知识类: 知乎、果壳、知识星球、得到APP、极客时间
- 资讯类: 今日头条、一点
- 社区类: 豆瓣、天涯、贴吧
- 小视频: 抖音、快手
- 直播类: 斗鱼、虎牙、战旗、熊猫
- 旅游类: 穷游网、携程、马蜂窝、去哪儿、飞猪
- 健身类: Keep、悦跑圈

    - 社交类
    - 电商类
    - 游戏类

U G C:

下厨房:
    虚拟币
    浏览记录: 每次点开一个都是一个浏览记录, 一张表, 一个是uid, 一个是文章的URL
             还可以用redis做一个队列,
             一般的浏览记录都是指定保存50条左右
    充值: 跟支付宝对接
    优惠卷: 优惠卷的设置表、与用户关联的表、
        优惠卷配置表:
            id  优惠额度    满足条件    类别   商家   开始时间     结束时间
            7     20          100      生鲜         20200729    20200829
        用户得到的优惠卷:
            uid  quan_id    count(个数)
            99      7           3
            99     21
            99     39
            注意: uid和quan_id 需要联合唯一

    红包: 类似于优惠卷


    打卡:
    等级: 评论积分、打卡积分、购买积分



缓存/缓冲
    缓冲: 数据从 "高速系统" 进入 "低速系统" 时的临时存储区叫做缓冲
    缓存: 数据从 "低速系统" 进入 "高速系统" 的临时存储区叫做缓存

数据库中的数据放入 Redis 中。

Python -> Redis -> MySQL

缓存命中率: 96%  (几乎所有的数据都是在Redis中)

String:
    - set(key, value)
    - get(key)
    - mset()
    - mget()
    - incrby()
Hash
    - hset
    - hget
    - hgetall()
    - hincrby()
List
    - lpush() / rpush()
    - lpop()  / rpop()
    - lrange(key,start,end)    # key 值和
    - ltrim(key,start,end)
Set
    - r.sadd('name',value1,value2)
    - r.smembers('name')
    - r.sismember()
    - r.inter()  /   union()  /  diff()
Zset(有序集合)
    - r.zadd('game',{'ll',81,'yr':75,'yx':98, 'yxl':100,'hy':78,'mh':59})
    - r.zrange() /  r.zrevrange()  降序排行
    - r.count() / r.zrecount()
    - r.zrank() / r.zrevrank()
    - zincrby()    指定增加1

--------------------------------------------------------------------------------------
Day08
缓存:
    存储资源:
        【寄存器、一级缓存、二级缓存、三级缓存】(这些都在CPU中)、内存、硬盘
    计算机的主存储设备: 内存

    Redis的运行机制：
        在启动时将硬盘中的数据加载到内存中:
        - dump rdb   redis运行过程中检查多少个key发生了修改,
                例如当五分钟发生修改了之后, 会将内存中的数据完整的镜像到rbd文件中,
                只保存最新的rdb文件。
        - aof   执行的任何操作都会在aof中进行记录。
        因此线上需要两个都开着

排行榜:
    1. 数据库
    ①将所有用户的积分保存到积分的从表
        HotRank
        --------
        uid       score
        21         2
        35         2037
        836        8347
              ...
    ②取出前50 的数据
        select * from HotRank order by score limit 50;
        (这个方式不是很好, 数据量大的时候速度过慢)

    ③-1 将前50 的数据写入到内存表中
        create table cache_hotrank(
            uid int,
            score int
        )charset = utf8mb4 engine = memory;

    ③-2 或者将前50的数据放入到Redis中

    ④ 从Redis中进行读取

    2. 完全使用Redis
        使用 zset 保存数据
        zincrby       指定增加1
        zrevrange     降序排行
